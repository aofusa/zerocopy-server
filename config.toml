# ==========================================
# High-Performance Reverse Proxy Server
# 設定ファイル
# ==========================================

[server]
listen = "0.0.0.0:443"

# HTTP to HTTPS リダイレクト（オプション）
#
# HTTPアクセスをHTTPSにリダイレクトするリスナーを起動します。
# ブラウザがhttp://でアクセスした場合、自動的にhttps://にリダイレクトされます。
#
# セキュリティ考慮事項:
# - HTTPではリダイレクトのみを行い、コンテンツは一切配信しません
# - 301 Moved Permanently を返すため、ブラウザがURLをキャッシュします
# - 初回HTTPアクセス時のみ平文通信が発生します
#
# 推奨: 公開サーバーではこの設定を有効にすることをお勧めします
#
# http = "0.0.0.0:80"

# ワーカースレッド数（オプション）
# 未指定または0の場合はCPUコア数と同じスレッド数を使用
threads = 4

# ====================
# HTTP/2・HTTP/3 設定
# ====================
#
# HTTP/2 と HTTP/3 のサポートを有効化できます。
# 各プロトコルを使用するには対応するフィーチャーでビルドする必要があります:
#   HTTP/2: cargo build --features http2
#   HTTP/3: cargo build --features http3
#   両方:   cargo build --features all-protocols

# HTTP/2 を有効化（TLS ALPN ネゴシエーション）
#
# 効果:
# - ストリーム多重化によるレイテンシ削減
# - HPACK ヘッダー圧縮によるオーバーヘッド削減
# - HTTP/1.1 へのフォールバック対応
#
# http2_enabled = true

# HTTP/3 を有効化（QUIC/UDP ベース）
#
# 効果:
# - 0-RTT 接続確立
# - Head-of-Line ブロッキング解消
# - 接続マイグレーション
#
# 注意:
# - UDP ベースのため kTLS は使用不可
# - GSO/GRO による高パフォーマンス UDP 処理を使用
#
# http3_enabled = true

# HTTP/3 リスナーアドレス (UDP)
# 未指定の場合は listen と同じアドレスを使用
#
# http3_listen = "0.0.0.0:443"


# ====================
# ログ設定（非同期ログの最適化）
# ====================
#
# ftlogは内部でバックグラウンドスレッドとチャネルを使用した非同期ログライブラリです。
# 「ftlogは同期ログ」という指摘は不正確です。
#
# ftlogのアーキテクチャ:
# - ログマクロ → 内部チャネルにプッシュ（ノンブロッキング）
# - バックグラウンドスレッド → チャネルから読み取りファイルI/O
#
# tokio::sync::mpscを使った追加の非同期化層は不要であり、
# むしろオーバーヘッドを増やす可能性があります。
# また、tokioのチャネルはmonoioランタイムと互換性がありません。
#
[logging]
# ログレベル: "trace", "debug", "info", "warn", "error", "off"
level = "info"

# ログチャネルサイズ（内部バッファ）
# 高負荷時のログドロップを防止するため、デフォルト(100)より大幅に増加
# 推奨範囲: 10000 - 1000000
channel_size = 100000

# フラッシュ間隔（ミリ秒）
# ログバッファをディスクにフラッシュする間隔
# 小さい値: 即座にログが書き込まれるがI/O負荷増
# 大きい値: I/O効率が良いがログ遅延
flush_interval_ms = 1000

# 最大ログファイルサイズ（バイト）
# 超過すると新しいファイルに切り替え（0=ローテーションなし）
max_log_size = 104857600

# ログファイルパス（オプション）
# 指定しない場合は標準エラー出力に出力
# file_path = "/var/log/zerocopy-server.log"


# ==========================================
# グローバルセキュリティ設定
# ==========================================
[security]

# 権限降格設定（Linux専用）
# rootで起動した場合、リスナー作成後に指定ユーザー/グループへ降格
# 
# 注意: 特権ポート（1024未満）を使用する場合は、以下のいずれかが必要:
#   1. CAP_NET_BIND_SERVICEケイパビリティを付与:
#      sudo setcap 'cap_net_bind_service=+ep' ./target/release/zerocopy-server
#   2. または非特権ポート（1024以上）を使用
#
# drop_privileges_user = "nobody"
# drop_privileges_group = "nogroup"

# グローバル同時接続上限（0 = 無制限）
# max_concurrent_connections = 10000


# ==========================================
# パフォーマンス設定
# ==========================================
[performance]

# SO_REUSEPORT の振り分け方式
# "kernel" = カーネルデフォルト（3元タプルハッシュ）
# "cbpf"   = クライアントIPベースのCBPF（キャッシュ効率向上、Linux 4.6+必須）
reuseport_balancing = "cbpf"

# Huge Pages (Large OS Pages) の使用
# true: mimallocでHuge Pages（2MB）を優先使用し、TLBミスを削減
# false: 通常の4KBページを使用
#
# 利点:
#   - TLB（Translation Lookaside Buffer）ミス削減
#   - 大容量メモリ使用時（バッファプール拡大）のページフォルト減少
#   - kTLS/splice時のカーネル連携で効果的（5-10%パフォーマンス向上）
#
# 要件（Linux）:
#   sudo echo 128 > /proc/sys/vm/nr_hugepages
#   または /etc/sysctl.conf に vm.nr_hugepages=128 を追加
#
# 注意:
#   - コンテナ環境（Docker/K8s）では無効化される可能性あり
#   - 利用不可の場合は自動的に通常ページにフォールバック
huge_pages_enabled = true


# ==========================================
# TLS設定
# ==========================================
[tls]

cert_path = "/path/to/cert.pem"
key_path = "/path/to/key.pem"

# kTLS有効化（Linux 5.15+、feature flag必須）
ktls_enabled = false

# kTLS有効化失敗時にrustlsへフォールバックするかどうか
# false: kTLS必須（失敗時は接続拒否）
# true: kTLS失敗時はrustlsで継続（デフォルト）
ktls_fallback_enabled = false


# ==========================================
# Upstream グループ定義（ロードバランシング）
# ==========================================
# 複数のバックエンドサーバーを定義し、リクエストを分散できます。
#
# アルゴリズム:
#   - round_robin: ラウンドロビン（順番に振り分け、デフォルト）
#   - least_conn: Least Connections（接続数が最小のサーバーを選択）
#   - ip_hash: クライアントIPハッシュ（同一クライアントは同一サーバーへ）
#
# 健康チェック設定（オプション）:
#   interval_secs: チェック間隔（秒、デフォルト: 10）
#   path: チェック対象パス（デフォルト: /）
#   timeout_secs: タイムアウト（秒、デフォルト: 5）
#   healthy_statuses: 成功と判断するステータスコード（デフォルト: [200, 201, 202, 204, 301, 302, 304]）
#   unhealthy_threshold: 何回連続失敗で unhealthy にするか（デフォルト: 3）
#   healthy_threshold: 何回連続成功で healthy に戻すか（デフォルト: 2）

# [upstreams."backend-pool"]
# algorithm = "round_robin"
# servers = [
#   "http://localhost:8080",
#   "http://localhost:8081",
#   "http://localhost:8082"
# ]
# 
#   [upstreams."backend-pool".health_check]
#   interval_secs = 10
#   path = "/health"
#   timeout_secs = 5
#   healthy_statuses = [200]
#   unhealthy_threshold = 3
#   healthy_threshold = 2

# ------------------------------------------
# SNI名指定付きHTTPSアップストリーム
# ------------------------------------------
# サーバーエントリは文字列と構造体の両方をサポート:
#   - 文字列形式: "http://localhost:8080"
#   - 構造体形式: { url = "https://192.168.1.100:443", sni_name = "api.example.com" }
#
# IPアドレス指定でHTTPSバックエンドに接続する場合、sni_nameでドメイン名を指定可能
# これにより、仮想ホスト構成のサーバーでも正しい証明書を取得できます
#
# [upstreams."https-pool"]
# algorithm = "least_conn"
# servers = [
#   { url = "https://192.168.1.100:443", sni_name = "api.example.com" },
#   { url = "https://192.168.1.101:443", sni_name = "api.example.com" },
#   "https://api.example.com:443"  # 通常のドメイン名指定（sni_name不要）
# ]


# ==========================================
# ホストベースのルーティング定義
# ==========================================
# ホスト名が完全一致した場合のデフォルトバックエンド
# 注意: path_routesより先に評価されるため、ホスト全体のデフォルトとして使用
#
# ルートごとのセキュリティ設定（security）オプション:
#
#   サイズ制限:
#     max_request_body_size         リクエストボディ最大サイズ（バイト）     デフォルト: 10MB
#     max_chunked_body_size         Chunked転送時の累積最大サイズ（バイト） デフォルト: 10MB
#     max_request_header_size       リクエストヘッダー最大サイズ（バイト）   デフォルト: 8KB
#
#   タイムアウト:
#     client_header_timeout_secs    クライアントヘッダー受信タイムアウト     デフォルト: 30秒
#     client_body_timeout_secs      クライアントボディ受信タイムアウト       デフォルト: 30秒
#     backend_connect_timeout_secs  バックエンド接続タイムアウト             デフォルト: 10秒
#
#   アクセス制御:
#     allowed_methods               許可するHTTPメソッド（配列）             デフォルト: すべて許可
#     rate_limit_requests_per_min   分間リクエスト数上限                     デフォルト: 0（無制限）
#     allowed_ips                   許可するIP/CIDR（配列）                  デフォルト: すべて許可
#     denied_ips                    拒否するIP/CIDR（配列、denyが優先）      デフォルト: なし
#
#   IP制限の評価順序: deny → allow（denyが優先）
#     例: allowed_ips = ["192.168.0.0/16"], denied_ips = ["192.168.1.100"]
#         → 192.168.1.100 は拒否、それ以外の 192.168.x.x は許可
#
#   コネクションプール:
#     max_idle_connections_per_host ホストごとの最大アイドル接続数           デフォルト: 8
#     idle_connection_timeout_secs  アイドル接続の維持時間                   デフォルト: 30秒
#
#   ヘッダー操作:
#     add_request_headers           バックエンドに転送前に追加するヘッダー   デフォルト: なし
#                                   特殊変数: $client_ip, $host, $request_uri
#     remove_request_headers        バックエンドに転送前に削除するヘッダー   デフォルト: なし
#     add_response_headers          クライアントに返送前に追加するヘッダー   デフォルト: なし
#     remove_response_headers       クライアントに返送前に削除するヘッダー   デフォルト: なし
#
#   WebSocket設定（Proxyバックエンドでのみ有効）:
#     websocket_poll_mode           ポーリングモード                         デフォルト: "adaptive"
#                                     - "fixed": 固定タイムアウト（低レイテンシ優先）
#                                     - "adaptive": バックオフ方式（CPU効率優先）
#     websocket_poll_timeout_ms     初期タイムアウト（ミリ秒）               デフォルト: 1
#                                     fixedモード: この値を固定で使用
#                                     adaptiveモード: この値から開始
#     websocket_poll_max_timeout_ms 最大タイムアウト（ミリ秒）               デフォルト: 100
#                                     adaptiveモードでのみ使用
#     websocket_poll_backoff_multiplier バックオフ倍率                       デフォルト: 2.0
#                                     タイムアウト発生時に現在値に掛ける倍率
#
#   WebSocketポーリング設定例:
#     リアルタイムゲーム（低レイテンシ最優先）:
#       websocket_poll_mode = "fixed"
#       websocket_poll_timeout_ms = 1
#
#     チャットアプリ（バランス重視）:
#       websocket_poll_mode = "adaptive"
#       websocket_poll_timeout_ms = 1
#       websocket_poll_max_timeout_ms = 50
#       websocket_poll_backoff_multiplier = 2.0
#
#     監視ダッシュボード（CPU効率優先）:
#       websocket_poll_mode = "adaptive"
#       websocket_poll_timeout_ms = 10
#       websocket_poll_max_timeout_ms = 200
#       websocket_poll_backoff_multiplier = 1.5
#
# ==========================================
# Prometheusメトリクス
# ==========================================
# メトリクスエンドポイント: /__metrics (GET)
# Prometheusスクレイピング用のエンドポイントを自動提供
#
# 利用可能なメトリクス:
#   zerocopy_proxy_http_requests_total          リクエスト総数（method, status, hostラベル付き）
#   zerocopy_proxy_http_request_duration_seconds リクエスト処理時間のヒストグラム
#   zerocopy_proxy_http_request_size_bytes      リクエストボディサイズ
#   zerocopy_proxy_http_response_size_bytes     レスポンスボディサイズ
#   zerocopy_proxy_http_active_connections      アクティブな接続数
#   zerocopy_proxy_http_upstream_health         アップストリームの健康状態

[host_routes."example.com"]
type = "File"
path = "/var/www/example"
mode = "sendfile"

[host_routes."api.example.com"]
type = "Proxy"
url = "http://localhost:8080"


# ==========================================
# パスベースのルーティング定義 (Nginx風)
# ==========================================
# 優先順位: 最長プレフィックス一致 (PathRouterの実装により自動解決)
#
# ルーティングの挙動:
# 
# 1. 静的ファイル（完全一致）
#    パスが末尾スラッシュなし & 設定pathがファイル → 完全一致
#    例: "/robots.txt" → リクエスト "/robots.txt" にのみマッチ
#
# 2. ディレクトリ配信（Alias動作）
#    設定pathがディレクトリ → プレフィックス除去後の残りパスをディレクトリに結合
#    例: "/static/" + path="/var/www/assets/"
#        リクエスト "/static/css/style.css" → "/var/www/assets/css/style.css"
#
# 3. インデックスファイル
#    index オプションでディレクトリアクセス時に返すファイルを指定
#    未指定の場合はデフォルトで "index.html" を使用
#
# 4. プロキシ（Proxy Pass動作）
#    プレフィックス除去後の残りパスをバックエンドURLに結合
#    例: "/api/" + url="http://backend:3000/app/"
#        リクエスト "/api/v1/users" → "http://backend:3000/app/v1/users"


# ------------------------------------------
# 静的ファイル（完全一致）
# ------------------------------------------
# リクエスト: /robots.txt → /var/www/robots.txt を返す
# リクエスト: /robots.txt/hoge → 404 Not Found
[path_routes."example.com"."/robots.txt"]
type = "File"
path = "/var/www/robots.txt"

# ------------------------------------------
# 静的ディレクトリ配信
# ------------------------------------------

# デフォルトインデックス (index.html)
[path_routes."example.com"."/static/"]
type = "File"
path = "/var/www/assets/"
mode = "sendfile"

# カスタムインデックス (profile.html)
[path_routes."example.com"."/user/"]
type = "File"
path = "/var/www/user/"
index = "profile.html"

# カスタムインデックス (dashboard.html)
[path_routes."example.com"."/app/"]
type = "File"
path = "/var/www/app/"
index = "dashboard.html"

# 末尾スラッシュなし（301リダイレクトなし）
[path_routes."example.com"."/docs"]
type = "File"
path = "/var/www/docs/"

# ------------------------------------------
# プロキシ配信
# ------------------------------------------

# シンプルなプロキシ
[path_routes."example.com"."/backend"]
type = "Proxy"
url = "http://localhost:3000"

# ------------------------------------------
# SNI名指定付きHTTPSプロキシ
# ------------------------------------------
# バックエンドがIPアドレス指定の場合、SNIにドメイン名を指定可能
# これにより、仮想ホスト構成のサーバーでも正しい証明書を取得できます
#
# [path_routes."example.com"."/internal-api/"]
# type = "Proxy"
# url = "https://192.168.1.100:443"
# sni_name = "api.internal.example.com"

# セキュリティ設定付きプロキシ
# - 許可メソッド: GET, POST, PUT のみ
# - ボディサイズ制限: 5MB
# - バックエンド接続タイムアウト: 5秒
# - レートリミット: 60リクエスト/分
[path_routes."example.com"."/api/"]
type = "Proxy"
url = "http://localhost:8080/app/"

  [path_routes."example.com"."/api/".security]
  allowed_methods = ["GET", "POST", "PUT"]
  max_request_body_size = 5_242_880
  backend_connect_timeout_secs = 5
  rate_limit_requests_per_min = 60

# ------------------------------------------
# 管理用API（IP制限付き）
# ------------------------------------------
# 内部ネットワークからのみアクセス許可
# - 許可: 192.168.0.0/16, 10.0.0.0/8, 127.0.0.1
# - 拒否: 192.168.1.100（特定のホストを除外）
[path_routes."example.com"."/admin/"]
type = "Proxy"
url = "http://localhost:9000/"

  [path_routes."example.com"."/admin/".security]
  allowed_ips = [
    "192.168.0.0/16",
    "10.0.0.0/8",
    "127.0.0.1"
  ]
  denied_ips = ["192.168.1.100"]
  allowed_methods = ["GET", "POST"]

# ------------------------------------------
# WebSocket プロキシ
# ------------------------------------------
# Connection: Upgrade と Upgrade: websocket ヘッダーを自動検出
# 101 Switching Protocols 後は双方向バイパス転送
# 
# [path_routes."example.com"."/ws/"]
# type = "Proxy"
# url = "http://localhost:3000"

# ------------------------------------------
# ヘッダー操作付きプロキシ
# ------------------------------------------
# X-Real-IP, X-Forwarded-Proto などを追加し、
# セキュリティヘッダーをレスポンスに付与
#
# [path_routes."example.com"."/secure-api/"]
# type = "Proxy"
# url = "http://localhost:8080"
#
#   [path_routes."example.com"."/secure-api/".security]
#   # バックエンドに転送前にヘッダーを追加
#   add_request_headers = { "X-Real-IP" = "$client_ip", "X-Forwarded-Proto" = "https" }
#   # バックエンドに転送前にヘッダーを削除
#   remove_request_headers = ["X-Debug-Token"]
#   # クライアントに返送前にセキュリティヘッダーを追加
#   add_response_headers = { "Strict-Transport-Security" = "max-age=31536000", "X-Frame-Options" = "DENY", "X-Content-Type-Options" = "nosniff" }

# ------------------------------------------
# リダイレクト設定
# ------------------------------------------
# 301/302/307/308 リダイレクトを設定
# WWW非対応やHTTPS強制、旧URL移行などに使用
#
# 例1: WWWへリダイレクト
# [path_routes."example.com"."/old-path/"]
# type = "Redirect"
# redirect_url = "https://www.example.com/new-path/"
# redirect_status = 301
# preserve_path = false
#
# 例2: パスを保持してリダイレクト
# [path_routes."example.com"."/legacy/"]
# type = "Redirect"
# redirect_url = "https://example.com/v2"
# redirect_status = 301
# preserve_path = true
# # /legacy/users → https://example.com/v2/users

# ------------------------------------------
# ロードバランシング（Upstream参照）
# ------------------------------------------
# upstreams セクションで定義したグループを参照
# url の代わりに upstream を指定
#
# [path_routes."example.com"."/api-lb/"]
# type = "Proxy"
# upstream = "backend-pool"
#
#   [path_routes."example.com"."/api-lb/".security]
#   rate_limit_requests_per_min = 100

# ------------------------------------------
# ルートパス
# ------------------------------------------
# "/" は完全一致（/へのリクエストのみマッチ）
# catch-all動作はなし: マッチしないパスは404
[path_routes."example.com"."/"]
type = "File"
path = "/var/www/index.html"

  [path_routes."example.com"."/".security]
  allowed_methods = ["GET"]
